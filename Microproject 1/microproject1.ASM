format PE console

entry start          

include 'win32a.inc'

section '.data' data readable writable

        ;ВАЖНО: так как мы выделяем очень много памяти под решето, в компиляторе нужно позволить это выделение
        ;для этого заходим в Options -> Compiler Setup и увеличиваем память до максимума
        ;ПРИМЕЧАНИЕ: программа может занимать до 2 МИНУТ для выполнения

        primes dd 1  ;сразу учитываем 2ку, которая не будет входить в алгоритм
        endMessage db 10,'Press any button to exit',0 ;сообщение в конце прграммы
        digit db '%d',0
        answer db 'Amount of non prime numbers between 1 and 0xFFFFFFFF is ',0   ;строка для вывода числового значения ответа в консоль
        A rt  0xFFFFFF  ;выделяем необходимую для реализации память
        B rt  0xFFFFFF
        С rt  0xFFFFF
        D rd  0xFFFFF


section '.code' code readable writable executable   

        start:
        ;1) Проходим по числам от 3 до 65536 для нахождения одного из простых множителей каждого числа из списка
        ;и составляем решето для нечётных чисел.
        call count_primes_h1

        ;2) Проходим по остатку чисел, которые уже отфильтрованы решетом. Если число простое,
        ;то бит индекса равен 0 и мы увеличиваем наш счётчик простых чисел
        call count_primes_h2

        ;3) Получаем количество всех составных чисел от 1 до 0xFFFFFFFF не учитывая 0
        call get_final_result

        ;4)Выводим результат в консоль
        call display_answer

        ;5) Завершаем программу
        call finish_program
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;Принимает в регистре еах число для вывода в консоль
;Выводит его по циферке
proc display_answer

        ;выводим сообщение об ответе
        push eax
        push answer
        call [printf]
        add esp, 4
        pop eax

        ;очищаем регист есх для счётчика цифр
        xor ecx, ecx

        ;отдаляемся от адреса в стаке, чтобы его не трогать
        sub esp, 4

        ;делим на 10, остаток пушим в стак, пока число не станет 0
        display_push_loop:
        xor edx,edx
        push ebx
        mov ebx,10
        div ebx
        pop ebx
        push edx
        inc ecx
        cmp eax,0
        jne display_push_loop

        ;выводим по очереди из стака с самого верха цифры в консоль
        mov ebx, ecx
        display_console:
        push digit
        call [printf]
        add esp, 8
        dec ebx
        cmp ebx, 0
        jne display_console

        ;возвращаем адрес выхода из процедуры на верх стака
        add esp, 4
        ret
        endp

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;работает с ячейкой памяти, в которой хранится количество простых чисел
;возвращает количество составных чисел от 1 до 0xFFFFFFFFF
proc get_final_result

        xor eax, eax  ;обнуляем регистр
        not eax       ;берём его обратное значение, то есть максимальное значение машинного слова из 32 бит
        sub eax, [primes]  ;вычитаем простые числа
        ret
        endp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;::::::::::::::


;принимает на вход регист есх в котором хранится индекс числа в битмапе.
;заполняет решето эрастофена до конца изучаемых чисел.
;ничего не возвращает, но меняет значения в битмапе.
proc fill_compound

        ;сохраняем значение регистра есх
        push ecx

        ;разница индексов между числами, котрое делит текукщее 2*индекс+1, где индекс- текущий.
        mov eax,2
        mul ecx
        add eax,1

        ;оставляем это значение разницы индексов в стаке, чтобы обращаться к нему по ходу выполнения программы.
        push eax

        fill_compound_loop:
        ;помещаем значение разницы индексов в регистр еах и возвращаем указатель стака обратно к нему же
        pop eax
        sub esp,4
        ;перемещаемся в индексу следущего числа.
        add ecx, eax

        ;сохраняем его  в стаке
        push ecx

        ;берём первые 3 бита из регистра счётчика, так как это числа 0-7
        ;очень удобно для подсчёта битов в байте.
        and cl, 0x7

        ;двигаем 1 на нужную позиция влево, которая соответсвует индексу текущего числа
        ;по модулю 8
        mov eax, 1
        shl eax, cl

        ;беерём индекс текущего числа и возвращаем указатель на него же.
        pop ecx
        sub esp, 4

        ;выясняем индекс байта в котором хранится бит текущего числа.
        shr ecx, 3

        ;помещаем туда 1 побитовым сложением.
        or byte[A+ecx], al

        ;восстанавливаем индекс текущего числа.
        pop ecx

        ;проверка на окончание цикла
        cmp ecx, 0x7FFFFFFF
        jb fill_compound_loop


        ;конец цмилка - возвращаем указатель стака на значение основной программы
        ;чтобы восстановить изначальное значение есх до входа в процедуру
        end_fill_compound:
        add esp,4
        pop ecx
        ret 
        endp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;работает с регистрами ecx - хранит индекс нечётных чисел в битмапе
;eax - помогает определить простое число или составное см процедуру check_prime
;[primes] - содержит в себе количество простых чисел от 3 до 0x8000
proc count_primes_h1
        ;инициализируем счётчик индексов
        mov ecx, 1

        ;основной цикл для вычисления простых чисел и заполнения решета эрастофена
        count_primes_loop:

        ;проверка текущего числа на простоту ссылаясь на значение его индекса в битмапе
        call check_prime
        cmp eax, 0
        jne count_primes_skip
        jmp count_primes_fill

        ;делаем проверку на окончание цикла
        count_primes_end_check:
        cmp ecx, 0x8000
        jb count_primes_loop
        jmp end_count_primes

        ;заполняет решето эрастофена числами, кратными текущему простому числу
        count_primes_fill:
        call fill_compound
        ;увеличиваем количество простых чисел и индекс числа
        inc [primes]
        inc ecx
        jmp count_primes_end_check
        
        ;преступаем к следущему числу, если нынешнее не является просытм числом
        count_primes_skip:
        inc ecx
        jmp count_primes_end_check

        ;окончание процедуры. Регист есх сохраняет индекс с которого начинается следующий цикл.
        end_count_primes:
        ret
        endp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;работает с регитсрами есх - хранит идекс нечетных чисел в битмапе
;еах - помогает для определния простое число или составное см процедуру check_prime
;[primes] ячейка памяти, которая хранит количетсво простых чисел.
proc count_primes_h2

        ;основной цикл процедуры, где мы проходим по индексам битмапа и проверям
        ;являются числа просытми и тогда заносим в счетчик или составными.
        count_primes_h2_loop:
        ;проверка на простоту. Если еах = 0, то простое
        call check_prime
        cmp eax, 0
        je inc_prime

        ;проверка на окончание цикла. Если счётчик в есх достиг конца, то завершает исполнение процедуры.
        ;в ином случае увеличивает значение есх на 1 продолжает работу.
        count_primes_h2_end_check:
        inc ecx
        cmp ecx, 0x7FFFFFFF
        jb count_primes_h2_loop
        jmp end_count_primes_h2

        ;инкрементируем количество простых чисел, встреченных в битмапе
        inc_prime:
        inc [primes]
        jmp count_primes_h2_end_check

        ;окончание работы процедуры
        end_count_primes_h2:
        ret
        endp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;работает с текущим значением есх - индекс в битмапе текущих нечётных чисел.
;смотрит значение бита соответсвующего числа, если значение бита 1, то число составное, если 0 то простое.
;устанавливает в индекс еах значение 0 если, число оказалось прпостым, иное если нет.
proc check_prime

;у нас есть байт, где записана информация о 8 числах. Мы берём 1 и двигаем его на нужное количество
;разрядов влево и перемножаем с известным байтом побитово. Если в искомом бите была 1, то результат умножения
;отличен от 0 и число составное, простое иначе.

        mov eax, 1
        ;созраняем изначальное значение регистра есх
        push ecx

        ;отфильтровываем последние три бита есх, чтобы взять счётчик есх по модулю 8
        ;берём именно этот регистр, потому что только он может делать побитовые сдвиги
        and cl,0x7

        ;двигаем единицу влево
        shl eax, cl

        ;восстанавливаем прежнее значение есх и возвращаем его обратно в стак
        pop ecx
        push ecx

        ;вычисляем индекс числа в массиве байтов, содержащих биты
        shr ecx, 3

        ;в младшем байте еах хранится нужное значение для перемножения
        ;теперь в еах хранится результат побитового произведения.
        and al, byte[A+ecx]

        ;восстанавливаем значение есх
        pop ecx

        ret
        endp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;Оканчивает работу программы
proc finish_program

    push endMessage
    call [printf]
    call [getch]
    push 0
    call [ExitProcess]
    ret
    endp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

section 'idata' import data readable 

        library kernel, 'kernel32.dll',\
                msvcrt, 'msvcrt.dll'

        import kernel,\
               ExitProcess, 'ExitProcess'

        import msvcrt,\
        printf, 'printf',\
        getch, '_getch'